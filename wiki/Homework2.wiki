#summary More design documentation

=Task 1:=
*a. Outline a High level appropriate Design or Software Architecture for your project. How do the requirements match with the chosen architecture?*

SEAT will be implemented using a model-view-controller architecture pattern.  The model will be implemented in a C# library.  This library, named SEATLibrary, and will implement all of the objects used by the program and a manager that is used to coordinate the various objects.  The controller and the model will be implemented within the GUI, which will be a separate C# project that uses the SEATLibrary.  For testing purposes, the SEATLibrary will also be used in TestingApplication, a command line program, which will provide most of the functionality that will be found in the GUI.

The requirements for the project work well with MVC.  However, the choice of MVC is primarily for the purpose of making development easier and producing code that is more maintainable.  The main part of the model, implemented in the SEATLibrary, can be quickly implemented.  This allows for the development of the GUI to continue while the model is enhanced as additional features are added.  As long as these two groups communicate, the development can proceed on parallel tracks. 


*b. Identify the types of design goals or tasks that solve specific problems. From these identify the software patterns that will be useful in your project.*

The primary goal in the design of SEAT is to produce code that is maintainable.  As this product will be in use after it has been developed, bugs and enhancements need to be easy.  Releasing the code under an open source license helps with this goal, but without a maintainable design the program may become unusable over time.  Tasks for the project will be divided in such a way the the components can be developed in a modular fashion.  Having the program be loosely coupled will force each component to be implemented in such a way that does not allow for complicated dependencies. 

*c. Prepare a complete UML based Software Design, with the following diagrams:*

 * A Class diagram. ( Are the good classes in Task 1 in here? Explain.)

<table style="width:auto;"><tr><td><a href="http://picasaweb.google.com/lh/photo/n_Cdmo5HJKwLUDSKCANQaQ?feat=embedwebsite"><img src="http://lh4.ggpht.com/_l4Rv5VGKzLQ/SsIsFI0lFiI/AAAAAAAAAWg/Eqnp85NslOU/s400/ClassDiagram.png" /></a></td></tr><tr><td style="font-family:arial,sans-serif; font-size:11px; text-align:right">From <a href="http://picasaweb.google.com/jjhatf02/GoogleCode?feat=embedwebsite">GoogleCode Photo Gallery</a></td></tr></table>

The main classes used by the application are the student class, the chair class, and the room class.  The SeatManager class functions as the manager overseeing the collection of students and collections of rooms that are stored in memory.  Additionally, the SeatManager class will have the responsibility of writing and reading the save file to the disk.  Lastly, the SeatManager will be responsible for making and managing the template files for rooms that are created.

The AssignmentVisitor is an implementation of the visitor design pattern that will implement an algorithm for placing students into seats in a room.  Currently, the only implementation of AssignmentVisitor is AssignmentBestEffort, but other algorithms may be constructed that have a different algorithm for placing students into the chairs of a classroom.  The AssignmentVisitor operates on the Room class and will modify the instance of the room that is passed to it.  Various algorithms may have errors that will cause them to not be executed properly.  This will need to be implemented so that the results of the running of the algorithm can be returned to the user.

The object oriented structure of the GUI is not documented above.  This design will be based on the default patterns that are used when constructing a WPF application.  In part 4 of this document the GUI is documented and much of the class design work will directly reflect these GUI layouts.

 * Use cases and corresponding Use Case diagrams
 * Sequence Diagrams
 * State Charts or Dynamic Diagrams
 * Collaboration Diagrams (optional)
 * Timing Diagrams (Optional)
 * Flow Charts for major complex methods (where needed)

*d. Mark the portions of the diagram where the Voice of the Customer ( in requirements or otherwise) is addressed.*


*e. Organize the Software Design Document to follow the IEEE standards and augment the same with the various UML diagrams, by reference or link. Are other libraries, packages used in your design? If you have referred, used other work on the internet that directly bears on your work, do note the same so that credit is given to existing open work. Note how your work will differ from theirs.*



=Task 2:= 
*Note how you intend to address Test Driven Design/Implementation/Development.*

*a. Which of the above diagrams are candidates for testing during the development? Are there aspects of design that will never be tested? Mark these as potentially for future work and agility.*

*b. Create a list of major error categories for your project. (Recall these are not just the compiler errors. These are design errors, process mismatches, plan changes and mismatches, documentation faults, version changes, architectural glitches etc. Think of the various life cycle phases.) Track these errors and log these as these errors occur. Note their categories (types).*

*c. Address risk analysis for Use, Misuse and Abuse scenarios. Document the types of design/coding defects that could be great risks. Note in a table form the major types of risk handling you could implement.*

*d. Address future changes that stakeholders would seek For each stakeholder, list the possible use, misuse and abuses. What design measures do you have to address these risks?*



=Task 3:=
*Generate an Operational Profile of your design, for each of your major Use Cases. Recall that an Operational Profile prioritizes various portions of your design (by modules, classes, subsystems as appropriate). These priorities may be based on criticality, frequency of usage, and the effort needed to have a valid set.*

=Task 4:=
*For each stakeholder, layout the GUI as appropriate. Discuss the layout  complexity/simplicity. Allocate review responsibilities as appropriate.*



*Calculate Design metrics such as the McCabeâ€™s Complexity, other Object Oriented Metrics, Cohesion metrics etc. based on your design diagrams. Note partial process metrics that will help the project development. Later, you will plot these at the end of the project.*